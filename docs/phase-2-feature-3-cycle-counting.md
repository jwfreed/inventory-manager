# Phase 2 — Feature 3: Cycle Counting (Count Docs, Variance Computation, Posting-Time Validations) — Schemas + Acceptance Criteria Only

This document defines the **schemas** and **documented computations** for cycle counting (stock counts) and variance posting.
It is **documentation only** (no migrations, no ORM models, no runtime implementation).

## Scope

Supports:
- Creating a count document for a location (or subset of items).
- Recording counted quantities per item and UOM.
- Computing variances against ledger-derived on-hand.
- Posting variances as ledger-correcting movements (inventory adjustments).
- Capturing audit context (counter, approver) without punitive language.

Out of scope:
- Lot/serial counting.
- Directed count scheduling / ABC classification.
- Approval workflows beyond capturing optional approval metadata.

## Conceptual Model

### Counts Are Observations; Variances Are Corrections

- A cycle count records what was physically observed at a point in time.
- The inventory ledger remains authoritative for “what the system thinks”.
- Posting a count produces an adjustment movement equal to the **variance**: `counted - on_hand_as_of_count_time`.
- Variances are diagnostic signals; capture reasons and approvals as audit metadata, not as blame.

## Proposed Relational Schema (PostgreSQL)

All timestamps are UTC.

### `cycle_counts`

| Column | Type | Null | Notes |
|---|---:|:---:|---|
| `id` | `uuid` | no | PK |
| `status` | `text` | no | enum-like: `draft`, `in_progress`, `posted`, `canceled` |
| `counted_at` | `timestamptz` | no | The time the count is considered effective (as-of time) |
| `location_id` | `uuid` | no | FK → `locations(id)`; the primary counted location |
| `notes` | `text` | yes | |
| `counter_id` | `uuid` | yes | FK → `users(id)`; who performed the count |
| `approved_by` | `uuid` | yes | FK → `users(id)`; who approved posting (if required) |
| `approved_at` | `timestamptz` | yes | |
| `inventory_adjustment_id` | `uuid` | yes | FK → `inventory_adjustments(id)`; variance document linkage |
| `inventory_movement_id` | `uuid` | yes | FK → `inventory_movements(id)`; expected `movement_type='adjustment'` |
| `posted_at` | `timestamptz` | yes | Posting timestamp; immutable once set |
| `created_at` | `timestamptz` | no | default now() |
| `updated_at` | `timestamptz` | no | |

Canonical linkage: `inventory_adjustment_id` is the authoritative link from a cycle count to its corrective action. `inventory_movement_id` is intentionally duplicated as a convenience pointer to the posted movement created by that adjustment. If both are present, the movement must be the movement generated by the linked adjustment.

Constraints / indexes:
- `check (status in ('draft','in_progress','posted','canceled'))`
- `foreign key (location_id) references locations(id)`
- `foreign key (inventory_adjustment_id) references inventory_adjustments(id)`
- `foreign key (inventory_movement_id) references inventory_movements(id)`
- `unique (inventory_adjustment_id)` (optional; one adjustment per count)
- `unique (inventory_movement_id)` (optional; one movement per count)
- `index (location_id, counted_at)`
- `index (status)`

### `cycle_count_lines`

| Column | Type | Null | Notes |
|---|---:|:---:|---|
| `id` | `uuid` | no | PK |
| `cycle_count_id` | `uuid` | no | FK → `cycle_counts(id)` |
| `line_number` | `integer` | no | 1-based; unique per count |
| `item_id` | `uuid` | no | FK → `items(id)` |
| `uom` | `text` | no | No conversions in Phase 2 |
| `counted_quantity` | `numeric(18,6)` | no | Must be ≥ 0 |
| `system_quantity` | `numeric(18,6)` | yes | Optional cached on-hand snapshot at posting time |
| `variance_quantity` | `numeric(18,6)` | yes | Optional cached variance at posting time |
| `reason_code` | `text` | yes | Required when `variance_quantity != 0` |
| `notes` | `text` | yes | |
| `created_at` | `timestamptz` | no | default now() |

Constraints / indexes:
- `foreign key (cycle_count_id) references cycle_counts(id)`
- `foreign key (item_id) references items(id)`
- `check (counted_quantity >= 0)`
- `unique (cycle_count_id, line_number)`
- `unique (cycle_count_id, item_id, uom)` (prevent duplicates per item/UOM within a count)
- `index (item_id)`

### Optional: `cycle_count_scopes` (Docs Only)

If you need a count document that targets only a subset of items within a location.

| Column | Type | Null | Notes |
|---|---:|:---:|---|
| `id` | `uuid` | no | PK |
| `cycle_count_id` | `uuid` | no | FK → `cycle_counts(id)` |
| `item_id` | `uuid` | no | FK → `items(id)` |
| `uom` | `text` | no | |

Constraints / indexes:
- `foreign key (cycle_count_id) references cycle_counts(id)`
- `foreign key (item_id) references items(id)`
- `unique (cycle_count_id, item_id, uom)`

## Documented Computations

### Ledger-derived system quantity (as-of)

For each `(item_id, location_id, uom)` on a cycle count:
- `system_quantity = sum(quantity_delta)` for posted movements with `occurred_at <= cycle_counts.counted_at`.

`counted_at` represents the effective snapshot time for variance; implementations may set it to “count completion time” by default, but must treat it as the authoritative as-of boundary for ledger aggregation.
Movements with `occurred_at > counted_at` are excluded from system quantity for this count; operationally, teams should minimize activity during counts or use the `counted_at` convention consistently.
Ledger time semantics: system quantity is derived using `occurred_at`, not posting time. Late-posted or backdated movements with `occurred_at <= counted_at` will affect historical system quantities. This is expected under the ledger model. Reporting cutoffs (if desired) are a later-phase policy.

Pseudo-query:
```sql
select
  l.item_id,
  l.location_id,
  l.uom,
  coalesce(sum(l.quantity_delta), 0) as system_quantity
from inventory_movement_lines l
join inventory_movements m on m.id = l.movement_id
where m.status = 'posted'
  and m.occurred_at <= :counted_at
  and l.location_id = :location_id
group by l.item_id, l.location_id, l.uom;
```

### Variance computation

For each cycle count line:
- `variance_quantity = counted_quantity - system_quantity`

Posting-time behavior:
- If `variance_quantity = 0`, no adjustment line is required for that item/uom.
- If non-zero, post an adjustment delta equal to `variance_quantity`.

If populated, `cycle_count_lines.system_quantity` and `cycle_count_lines.variance_quantity` are posting-time snapshots used for audit/reporting; they must match the computation at posting time and are not recomputed later.

## Posting-Time Validations (Documented)

### Cycle count posting vs adjustment posting (atomic)

Posting-time validation (application/service layer):
- A cycle count may exist as `draft/in_progress` with no linked adjustment/movement.
- Posting is atomic (all-or-nothing):
  - `cycle_counts.status` transitions to `posted`,
  - an `inventory_adjustment` is created/linked,
  - and a linked `inventory_movement` of type `adjustment` is posted for the variance deltas.

Cancel policy (Phase 2): `canceled` is a draft-only state. Once a cycle count is posted, it cannot be canceled or edited. Corrections require a new cycle count (and, if applicable, a new adjustment/movement).

### Occurred/count time alignment

Posting-time validation:
- The adjustment movement’s `occurred_at` must equal `cycle_counts.counted_at`.

### UOM and uniqueness

Posting-time validation:
- Cycle count lines are unique per `(item_id, uom)` within a count.
- No unit conversions; `uom` must be consistent with ledger aggregation.
 - If `variance_quantity != 0`, a `reason_code` is required (non-punitive language: “variance reason” vs “error”).

### Negative on-hand boundary

- Counted quantities must be ≥ 0.
- Variance deltas may be negative (if counted < system).
- If a future policy disallows negative on-hand, enforce it at posting time; Phase 2 permits negatives per Phase 0.

### Idempotency / re-posting

Posting-time validation:
- Posted cycle counts are immutable; corrections require a new cycle count (or a new adjustment) rather than editing prior posted results.
- Posting-time snapshots (`system_quantity`, `variance_quantity`) are immutable once `posted_at` is set.

## Acceptance Criteria (Schemas + Computations Only)

1. Documentation defines schemas for `cycle_counts` and `cycle_count_lines` including statuses, `counted_at`, location, and counted quantities.
2. Documentation defines variance computation from ledger-derived system quantity (as-of `counted_at`) and includes a pseudo-query.
3. Documentation defines linkage from cycle counts to `inventory_adjustments` and adjustment-type `inventory_movements` (docs-only).
4. Documentation defines posting-time validations for atomic posting, time alignment, UOM rules, and immutability of posted counts.
5. No production code is added (no migrations executed, no ORM/runtime model implementation).
